<!DOCTYPE html>
<html>
  <head>
    <title> NetTLP: Adapter </title>
    <link rel="stylesheet" type="text/css" href="../css/web.css">
    <link rel="stylesheet" type="text/css" href="../css/prism.css">
  </head>
  <body>

    <header>
      <h1> <a href="index.html">NetTLP</a>: Adapter </h1>
    </header>

    <main>

      <section>
	<h2> Overview </h2>
	<p>
	  NetTLP adapter is a PCIe device that bridges a PCIe link and an Ethernet link.
	  When the NetTLP adapter receives TLPs from the PCIe link, the NetTLP adapter encapsulates each TLP in Ethernet, IP, UDP, and NetTLP header for sequencing and timestamping and sends the packets to the device host via the Ethernet link.
	  When the NetTLP adapter receives a UDP packet from the Ethernet link, the NetTLP adapter checks whether the packetâ€™s payload is a TLP, decapsulates the packet, and sends the inner TLP to the PCIe link.
	  As a result, from the perspective of the adapter host, all TLPs sent from the device host by the software are recognized as TLPs generated by the NetTLP adapter.
	</p>

	<div class="img">
	  <a href="fig/adapter.png"><img src="fig/adapter.png" class="size75"/></a>
	  <p>Figure 1: NetTLP adapter overview</p>
	</div>

	<p>
	  The current NetTLP adapter (v0.17) has three Base Address
	  Registers (BAR). BAR0 is used to store adapter specific
	  information (i.e., MAC address and IP address), and BAR2 is
	  used to store MSI-X table. BAR4 is quite special:
	  Transaction Layer Packets (TLPs) to the BAR are encapsulated
	  in Ethernet, IP, and UDP headers, and transmitted to the
	  device host via the 10Gbps Ethernet Link. In the above
	  example, memory accesses to 0xb0000000-0xbfffffff in the
	  MMIO space are delivered to the device host by
	  Ethernet/IP/UDP encapsulation.
	</p>

      </section>

      <section>
	<h2> Build the adapter bit file </h2>

	<h3> Build environment </h3>
	<ul> 
	  <li> Xilinx KC705 Eval board (EK-K7-KC705-G)
	  <ul>
	       <li> Vivado 19.2 </li>
	       <li> Additional IP license: 10 Gigabit Ethernet Media Access Controller (10GEMAC) </li>
	  </ul>
	  </li>
	</ul>

	<p>
	  All source files can be found at <a href="https://github.com/NetTLP/adapter/releases"> https://github.com/NetTLP/adapter/</a>.
	  And the bit file can be found at <a href="https://github.com/NetTLP/adapter/releases"> https://github.com/NetTLP/adapter/releases</a>.
	  We use the files created by Xilinx for the si5324 configurations.
	  So you need to get the <a href="https://www.xilinx.com/products/boards-and-kits/dk-v7-vc709-g.html#documentation">rdf0285-vc709-connectivity-trd-2014-3.zip</a> file from the Xilinx web page to build the bit image.

	</p>

	<pre><code class="language-shell-session">$ git clone https://github.com/NetTLP/adapter.git

$ unzip rdf0285-vc709-connectivity-trd-2014-3.zip
$ cp v7_xt_conn_trd/hardware/sources/hdl/clock_control/kcpsm6.v adapter/boards/kc705/rtl/clock_control/
$ cp v7_xt_conn_trd/hardware/sources/hdl/clock_control/clock_control.v adapter/boards/kc705/rtl/clock_control/
$ cp v7_xt_conn_trd/hardware/sources/hdl/clock_control/clock_control_program.v adapter/boards/kc705/rtl/clock_control/

$ source /tools/Xilinx/Vivado/2019.2/settings64.sh
$ cd adapter/boards/kc705

# lint check
$ sudo apt install verilator
$ make lint

# verilog simulation
$ make sim

# build bit file
$ make
$ ls build/nettlp-adapter.bit
	</code></pre>
      </section>

      <section>
	<h2> NetTLP header </h2>

	<h3> Overview </h3>
	<p>
	  All TLPs on an Ethernet link are encapsulated in Ethernet, IP, UDP, and NetTLP header.
	  The NetTLP header constructs the packet sequence number field and the timestamp field, and all values are generated by the NetTLP adapter.
	  The NetTLP header length is fixed 6-byte.
	  And current value of the timestamp field is generated by the Ethernet clock and the timestamp resolution is 6.4ns (we will replace the timestamp source from the Ethernet clock to the PCIe clock in a future release).
	</p>

	<h3> Packet format </h3>
	<pre><code class="language-shell-session">
 2               1               0B
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |           Sequence            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |           Timestamp           |
 |                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |              TLP              |
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	</code></pre>
	<p> Port number: 0x3000 + (TLP_tag & 0xF) </p>

	<h3> Header fields </h3>
	<ul> 
		<li>Sequence, 16b, TLP Packet sequence number</li>
		<li>Timestamp, 32b, Received timestamp</li>
		<li>TLP, 12B+, Raw Transaction Layer Packet</li>
	</ul>
      </section>

      <section>
	<h2> PCIe configuration packet </h2>

	<h3> Overview </h3>
	<p>
	  The device host can access the PCIe configuration space of the NetTLP adapter by using the PCIe configuration packet.
	  The current adapter implementation can read all PCIe config spaces by specifying an address.
	  However, many PCIe configuration fields cannot be written due to limitations of the PCIe IP Core.
	  The R/W permission depends on the PCIe base specification.
	  If you want to modify the PCIe configuration space, please use PCIe Endpoint IP Core settings in the Xilinx vivado.
	  This PCIe configuration space API will be improved in the future.
	</p>

	<h3> LibTLP API </h3>
	<p>
	  TBD
	</p>

	<h3> Packet format </h3>
	<pre><code class="language-shell-session">
 2               1               0B
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |CMD| Mask  |       DWaddr      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |             Data              |
 |                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	</code></pre>
	<p> Port number: 0x4001 </p>

	<h3> Header fields </h3>
	<ul> 
		<li>CMD, 2b, PCIe configuration</li>
<table border="1">
<tr>
<th>Value</th>
<th>Description</th>
</tr>
<tr>
<td>00b</td>
<td>Data read</td>
</tr>
<tr>
<td>01b</td>
<td>Data write</td>
</tr>
</table>
		<li>Mask, 4b, Byte enable</li>
<table border="1">
<tr>
<th>Value</th>
<th>Description</th>
</tr>
<tr>
<td>0001b</td>
<td>Lower Byte enable</td>
</tr>
<tr>
<td>0011b</td>
<td>Lower 2 Byte enalbe</td>
</tr>
<tr>
<td>1100b</td>
<td>Higher 2 Byte enalbe</td>
</tr>
<tr>
<td>1111b</td>
<td>All Byte enalbe</td>
</tr>
</table>

		<li>DWaddr, 12b, PCIe configuration address (DWORD)</li>
<table border="1">
<tr>
<th>DWaddr</th>
<th>Mask</th>
<th>RW</th>
<th>Description</th>
</tr>

<tr>
<td>00h</td>
<td>0011b</td>
<td>R</td>
<td>Device ID</td>
</tr>

<tr>
<td>00h</td>
<td>1100b</td>
<td>R</td>
<td>Vender ID</td>
</tr>

<tr>
<td>01h</td>
<td>0011b</td>
<td>R</td>
<td>Status</td>
</tr>

<tr>
<td>01h</td>
<td>1100b</td>
<td>RW</td>
<td>Command</td>
</tr>

<tr>
<td>04h</td>
<td>1111b</td>
<td>R</td>
<td>BAR0</td>
</tr>

<tr>
<td>05h</td>
<td>1111b</td>
<td>R</td>
<td>BAR1</td>
</tr>

<tr>
<td>06h</td>
<td>1111b</td>
<td>R</td>
<td>BAR2</td>
</tr>

<tr>
<td>07h</td>
<td>1111b</td>
<td>R</td>
<td>BAR3</td>
</tr>

<tr>
<td>08h</td>
<td>1111b</td>
<td>R</td>
<td>BAR4</td>
</tr>

<tr>
<td>09h</td>
<td>1111b</td>
<td>R</td>
<td>BAR5</td>
</tr>

<tr>
<td>0Ah</td>
<td>1111b</td>
<td>R</td>
<td>BAR6</td>
</tr>

<tr>
<td>0Bh</td>
<td>0011b</td>
<td>R</td>
<td>Sub Device ID</td>
</tr>

<tr>
<td>0Bh</td>
<td>1100b</td>
<td>R</td>
<td>Sub Vender ID</td>
</tr>
</table>
		<li>Data, 32b, Data</li>
	</ul>
      </section>

      <section>
	<h2> NetTLP adapter command packet </h2>

	<h3> Overview </h3>
	<p>
	  The NetTLP adapter settings such as the value of the Ethernet and IP packet header used for encapsulation can be modified by using the NetTLP adapter command.
	  In addition, the PCIe requester ID of the NetTLP adapter allocated by a root complex can be gotten with this API.
	  The device host should get the requester ID using this API and use the ID to generate the TLP header.
	</p>

	<h3> LibTLP API </h3>
	<p>
	  TBD
	</p>

	<pre><code class="language-shell-session">
 2               1               0B
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |    opcode     |     DWaddr    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |             Data              |
 |                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	</code></pre>
	<p> Port number: 0x4002 </p>

	<h3> Header fields </h3>
	<ul> 
		<li>opcode, 8b, opcode for configuring the nettlp adapter</li>
<table border="1">
<tr>
<th>Command</th>
<th>Description</th>
</tr>

<tr>
<td>0001_0000b</td>
<td>Data read</td>
</tr>

<tr>
<td>0001_0001b</td>
<td>Data write</td>
</tr>

<tr>
<td>0010_0000b</td>
<td>[not implemented] Get Magic code</td>
</tr>

<tr>
<td>0010_0001b</td>
<td>[not implemented] Get Timestamp value</td>
</tr>

<tr>
<td>0010_0010b</td>
<td>[not implemented] Adapter reset</td>
</tr>
</table>
		<li>DWaddr, 8b, NetTLP adapter configuration address (DWORD)</li>
<table border="1">
<tr>
<th>DWaddr</th>
<th>RW</th>
<th>Description</th>
</tr>

<tr>
<td>00h</td>
<td>R</td>
<td>Magic code (default: 01234567)</td>
</tr>

<tr>
<td>01h</td>
<td>RW</td>
<td>Destination MAC address low</td>
</tr>

<tr>
<td>02h</td>
<td>RW</td>
<td>Destination MAC address high</td>
</tr>

<tr>
<td>03h</td>
<td>RW</td>
<td>Source MAC address low</td>
</tr>

<tr>
<td>04h</td>
<td>RW</td>
<td>Source MAC address high</td>
</tr>

<tr>
<td>05h</td>
<td>RW</td>
<td>Destination IP address</td>
</tr>

<tr>
<td>06h</td>
<td>RW</td>
<td>Source IP address</td>
</tr>

<tr>
<td>07h</td>
<td>RW</td>
<td>Destination port number</td>
</tr>

<tr>
<td>08h</td>
<td>RW</td>
<td>Source port number</td>
</tr>

<tr>
<td>10h</td>
<td>R</td>
<td>Requester ID {bus_number, device_number, function_number}</td>
</tr>

</table>

		<li>Data, 32b, Data</li>
	</ul>
      </section>
    </main>

    <footer>
      &copy; haeena.dev.
    </footer>

    <script type="text/javascript" src="../js/prism.js"></script>
  </body>
</html>
